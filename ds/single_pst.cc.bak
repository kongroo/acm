#include <bits/stdc++.h>
using namespace std;


template <typename T> struct SinglePST {
    int n;
    vector<T> V;
    vector<int> Rt, Lc, Rc;
    using Func = function<T(T, T)>;
    Func op, alter;
    SinglePST(const vector<T>& A, Func op = plus<T>(), Func alter = plus<T>()
             ): n(1 << (32 - __builtin_clz(A.size()))), V(n * 2),
        Lc(n * 2), Rc(n * 2), op(op), alter(alter) {
        copy(A.begin(), A.end(), V.begin() + n);
        Rt.push_back(1);
        for (int i = n - 1; i > 0; i--)
            Lc[i] =  i << 1, Rc[i] = i << 1 | 1, V[i] = op(V[Lc[i]], V[Rc[i]]);
    }
    void modify(int p, T val) {
        assert(0 <= p && p < n);
        static const function<int(int, int, int)> modify_ = [&](int o, int L, int R) {
            int M = (L + R) / 2, no = int(V.size());
            Lc.push_back(Lc[o]), Rc.push_back(Rc[o]), V.push_back(T());
            if (M == L) V[no] = alter(V[o], val);
            else {
                if (p < M) Lc[no] = modify_(Lc[o], L, M);
                else Rc[no] = modify_(Rc[o], M, R);
                V[no] = op(V[Lc[no]], V[Rc[no]]);
            }
            return no;
        };
        Rt.push_back(modify_(Rt.back(), 0, n));
    }
    T query(int l, int r, int t = -1) {
        assert(l < r && 0 <= l && r <= n);
        static const function<T(int, int, int)> query_ = [&](int o, int L, int R) {
            if (L >= l && R <= r) return V[o];
            int M = (L + R) / 2;
            bool bl = false, br = false;
            T left, right;
            if (M > l) left = query_(Lc[o], L, M), bl = true;
            if (M < r) right = query_(Rc[o], M, R), br = true;
            return !bl ? right : !br ? left : op(left, right);
        };
        if (t < 0) t = (int)Rt.size() - 1;
        assert(t < (int)Rt.size());
        return query_(Rt[t], 0, n);
    }
};


// 51Nod. 1175
int main() {
    int n;
    scanf("%d", &n);
    vector<int> A(n);
    for (int i = 0; i < n; i++) scanf("%d", &A[i]);
    auto B(A);
    sort(B.begin(), B.end());
    B.erase(unique(B.begin(), B.end()), B.end());
    auto pst = new SinglePST<int>(vector<int>(B.size() + 1));
    for (auto x : A) pst->modify(lower_bound(B.begin(), B.end(), x) - B.begin(), 1);
    for (int i = 0; i <= n; i++) {
        puts("");
        for (int j = 0; j < B.size(); j++) printf("%d ", pst->query(j, j + 1, i));
    }
    puts("");
    int q;
    scanf("%d", &q);
    while (q--) {
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        k = r - l + 2 - k;
        int ll = -1, rr = (int)B.size() - 1;
        while (ll + 1 != rr) {
            int m = (ll + rr + 1) / 2;
            int cnt = pst->query(0, m + 1, r + 1) - pst->query(0, m + 1, l);
            if (cnt >= k) rr = m;
            else ll = m;
        }
        printf("%d\n", B[rr]);
    }
    return 0;
}
